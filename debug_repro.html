<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Debug Repro</title>
</head>

<body>
    <ul>
        <li><!---->5+ years of development Experience<span class="white-space-pre"> </span></li>
        <li><!---->Strong software engineering fundamentals, with a commitment to mentoring less experienced
            engineers.<!----></li>
    </ul>
    <script>
        (function () {
            'use strict';
            const CONFIG = {
                minUppercaseLen: 2,
                minCapitalizedLen: 3,
                terminators: new Set(['.', '!', '?', '…']),
                blockTags: new Set([
                    'DIV', 'P', 'LI', 'TD', 'TH', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
                    'HEADER', 'FOOTER', 'SECTION', 'ARTICLE', 'ASIDE', 'BLOCKQUOTE', 'FIGCAPTION'
                ]),
                excludedTags: new Set([
                    'SCRIPT', 'STYLE', 'NOSCRIPT', 'TEXTAREA', 'INPUT', 'SELECT', 'OPTION',
                    'CODE', 'PRE', 'IFRAME', 'SVG', 'CANVAS', 'KBD', 'VAR', 'B-B'
                ]),
                excludedAttrs: ['contenteditable']
            };
            const RE_UPPERCASE = new RegExp(`^\\b[A-Z]{${CONFIG.minUppercaseLen},}\\b$`);
            const RE_CAPITALIZED = new RegExp(`^\\b[A-Z][a-z]{${CONFIG.minCapitalizedLen - 1},}\\b$`);
            const blockFirstWordSeen = new WeakMap();
            let atSentenceStart = true;

            function isBlockElement(node) {
                return node.nodeType === Node.ELEMENT_NODE && CONFIG.blockTags.has(node.tagName);
            }
            function getBlockParent(node) {
                let current = node.parentElement;
                while (current) {
                    if (isBlockElement(current)) return current;
                    if (current === document.body) return current;
                    current = current.parentElement;
                }
                return document.body;
            }
            function shouldSkipNode(node) {
                let current = node.parentElement;
                while (current) {
                    if (CONFIG.excludedTags.has(current.tagName)) return true;
                    current = current.parentElement;
                }
                return false;
            }
            function processTextNode(textNode) {
                if (shouldSkipNode(textNode)) return;
                const text = textNode.nodeValue;
                if (!text.trim()) return;
                const blockParent = getBlockParent(textNode);

                console.log('Processing node:', text.substring(0, 20) + '...', 'Parent:', blockParent.tagName);

                const tokens = text.split(/([.!?…]|\s+|[^a-zA-Z.!?…\s]+)/).filter(t => t);
                const fragment = document.createDocumentFragment();
                let modified = false;
                tokens.forEach(token => {
                    if (CONFIG.terminators.has(token)) {
                        atSentenceStart = true;
                        fragment.appendChild(document.createTextNode(token));
                        return;
                    }
                    if (!/^[a-zA-Z]+$/.test(token)) {
                        fragment.appendChild(document.createTextNode(token));
                        return;
                    }
                    const isBlockStart = !blockFirstWordSeen.get(blockParent);
                    if (isBlockStart) {
                        console.log('Block start detected:', token, 'for parent:', blockParent.tagName);
                        blockFirstWordSeen.set(blockParent, true);
                    }
                    const isSentenceStart = atSentenceStart;
                    if (isSentenceStart) {
                        atSentenceStart = false;
                    }
                    let shouldBold = false;
                    if (!isBlockStart && !isSentenceStart) {
                        if (RE_UPPERCASE.test(token) || RE_CAPITALIZED.test(token)) {
                            shouldBold = true;
                        }
                    }
                    if (shouldBold) {
                        console.log('Bolding:', token);
                        const b = document.createElement('b-b');
                        b.textContent = token;
                        b.style.fontWeight = 'bold';
                        fragment.appendChild(b);
                        modified = true;
                    } else {
                        fragment.appendChild(document.createTextNode(token));
                    }
                });
                if (modified) {
                    console.log('Modified node:', text.substring(0, 20) + '...');
                    textNode.replaceWith(fragment);
                }
            }
            function traverse(root) {
                const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
                const nodes = [];
                let node;
                while ((node = walker.nextNode())) {
                    nodes.push(node);
                }
                nodes.forEach(processTextNode);
            }

            console.log('Starting traversal');
            traverse(document.body);

            const observer = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            traverse(node);
                        } else if (node.nodeType === Node.TEXT_NODE) {
                            processTextNode(node);
                        }
                    });
                });
            });
            observer.observe(document.body, { childList: true, subtree: true });
        })();
    </script>
</body>

</html>